<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">

  <link rel="canonical" href="http://localhost:4000/%E8%AF%A6%E8%A7%A3%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B3%95-%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BD%A0%E6%89%BE%E5%BE%97%E5%88%B0%E6%9C%80%E8%AF%A6%E7%BB%86%E7%9A%84" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta name="description" content="什么是关键路径法CPM？">

  <meta property="og:site_name" content="BertrandDigitalGarden">
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <!-- <script async src="https://www.googletagmanager.com/gtag/js?id=G-DBYSXF7WKD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-DBYSXF7WKD');
  </script> -->
  
  <!-- 
  <script src="https://unpkg.com/@waline/client@v2/dist/waline.js"></script>
  <link
    rel="stylesheet"
    href="https://unpkg.com/@waline/client@v2/dist/waline.css"
  />  
  -->
  
  
  <!-- <script async defer data-website-id="0dc17886-9c5c-4bb7-b097-104eb7c28c72" src="https://umami-production-7220.up.railway.app/umami.js"></script> -->
  
  
  <!-- Start of Howxm client code snippet -->
  <script>
  function _howxm(){_howxmQueue.push(arguments)}
  window._howxmQueue=window._howxmQueue||[];
  _howxm('setAppID','352e66d3-cc84-42ce-ac80-a43a12abf84b');
  (function(){var scriptId='howxm_script';
  if(!document.getElementById(scriptId)){
  var e=document.createElement('script'),
  t=document.getElementsByTagName('script')[0];
  e.setAttribute('id',scriptId);
  e.type='text/javascript';e.async=!0;
  e.src='https://static.howxm.com/sdk.js';
  t.parentNode.insertBefore(e,t)}})();
  </script>
  <!-- End of Howxm client code snippet -->
  
  <script type="text/javascript">
      (function(c,l,a,r,i,t,y){
          c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
          t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
          y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
      })(window, document, "clarity", "script", "jurm89uqvq");
  </script>
  
  <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=">

  <link rel="stylesheet" href="/styles.css">

  
  <meta property="og:description" content="什么是关键路径法CPM？"/>
  

  
  <meta property="og:title" content="详解关键路径法，这可能是你找得到最详细的...">
  <meta property="og:type" content="article">
  

  
  <meta property="article:published_time" content="2024-03-09T23:52:57+08:00">
  <meta property="article:author" content="http://localhost:4000/">
  

  <meta property="og:url" content="http://localhost:4000/%E8%AF%A6%E8%A7%A3%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B3%95-%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BD%A0%E6%89%BE%E5%BE%97%E5%88%B0%E6%9C%80%E8%AF%A6%E7%BB%86%E7%9A%84" />

  

  <title>
    
      详解关键路径法，这可能是你找得到最详细的... &mdash; BertrandDigitalGarden
    
  </title>
</head>

  <body>
    <nav><div>
    <a class="internal-link" href="/"><b>BertrandDigitalGarden</b></a>
</div></nav>
    <div class="wrapper">
      <main><article>
  <div>
    <h1>详解关键路径法，这可能是你找得到最详细的...</h1>
    <!-- 更新时间一直都是显示为构建时间，先屏蔽 -->
    <time datetime="2024-03-09">
      最后更新于 2024-03-09
      
    </time> 
  </div>

  <div id="notes-entry-container">
    <content>
      <html><body>
<p><strong>什么是关键路径法CPM？</strong></p>

<p>关键路径法用于在进度模型中估算项目<strong>最短工期</strong>，确定逻辑网络路径的进度灵活性大小。这种进度网络分析技术在<strong>不考虑任何资源限制</strong>的情况下，沿进度网络路径使用顺推与逆推法，计算出所有活动的最早开始ES、最早结束EF、最晚开始LS和最晚完成LF日期。</p>

<p>由此得到的最早和最晚的开始和结束日期<strong>并不一定就是项目进度计划</strong>，而只是把既定的参数（活动持续时间、逻辑关系、提前量、滞后量和其他已知的制约因素）输入进度模型后所得到的一种结果，表明活动可以在该时段内实施。</p>

<p><strong>什么是关键路径？</strong></p>

<ul>
  <li>关键路径是项目中时间最长的活动顺序，决定着可能的项目最短工期。</li>
  <li>计算关键路径的长度时，需要将路径上的所有活动的持续时间、提前量（负的）和滞后量（正的）加总在一起。</li>
  <li>最长路径的总浮动时间最少，通常为零；进度网络图<strong>可能有多条关键路径</strong>。</li>
  <li>长度仅次于关键路径的路径称为次关键路径，次关键路径也可能有多条。</li>
  <li>借助进度计划软件来规划时，为了达成相关方的限制要求，可以自行定义用于确定关键路径的参数。</li>
</ul>

<p><strong>关键路径法的作用</strong></p>

<p>关键路径法用来计算进度模型中的关键路径、总浮动时间和自由浮动时间，或逻辑网络路径的<strong>进度灵活性大小</strong>。</p>

<p><strong>最早时间和最晚时间</strong></p>

<ul>
  <li>最早开始结束时间</li>
</ul>

<p><strong>ES：最早开始时间</strong>(Earliest Start)，是指某项活动能够开始的最早时间，只决定于项目计划，只要计划的条件满足了就可以开始的时间。</p>

<p><strong>EF：最早结束时间</strong>(Earliest Finish)，是指某项活动能够完成的最早时间。</p>

<p>其中EF = ES+DU， DU为活动持续时间，顺推法先知道开始时间。</p>

<ul>
  <li>最晚结束和开始时间</li>
</ul>

<p><strong>LF：最迟结束时间</strong>(Latest Finish)，是指为了使项目在要求完工时间内完成，某项活动<strong>必须</strong>完成的最迟时间。往往决定于相关方（客户或管理层）的限制。</p>

<p><strong>LS：最迟开始时间</strong>(Latest Start)，是指为了使项目在要求完工时间内完成，某项活动必须开始的最迟时间</p>

<p>其中LS = LF -DU，DU为持续时间，逆推法先知道结束时间。</p>

<ul>
  <li>图形表示</li>
</ul>

<p>按照《PMBOK指南》的推荐，采用图6-24的方式来标注活动的ES、EF、DU、LF、LS以及活动名称（ID）</p>

<p>图6-24</p>

<p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-ebf37478602729127fe038d43f616768_b.jpg&amp;valid=false" alt=""></p>

<p>@提示</p>

<p>在考试中未必需要把图6-24的格子画出来，只需要按照图中的方位进行标注就可以了，这样做的好处时在计算TF和FF时不容易出错。TF和FF的计算方法参见本节后续内容。</p>

<p><strong>活动从第0天开始还是从第1天开始</strong></p>

<p>采用顺推法和逆推法进行进度网络路径计算时，需要关注活动是从第0天开始还是从第1天开始，不同的假设计算的结果是不一样的。首先需要明确以下几个概念。</p>

<ul>
  <li>活动的持续时间DU是指活动的工作时间段，例如一个活动持续时间是24小时，是指3个工作日（每天8小时）。</li>
  <li>活动的开始时间是指活动开工日的上班开始时间；活动结束是指开工日的下班时间。也就是说假设一个活动的持续时间是2天，是指从第1天上班时间，到第2天下班时间的所有工作时间段。</li>
</ul>

<p>所谓活动从第0天还是第1天开始，意思是说要不要把活动开始的那一天计算在工作时间段内。因为现实中第0天是不存在的，所以活动开始的那一天就不需要计算在内；而活动从第1天开始，由于第1天是存在的，就需要计算在工作时间段内。这两种情况导致当前活动的EF或者LS，紧后活动的ES和LF在计算时要考虑是否减去或加上这1天的问题。</p>

<p>无论是从第0天开始，还是第1天开始，都不会影响关键路径的和浮动时间的计算方法，但是考试中如果弄错了则会影响计算结果，考试中为了简化计算通常采用第0天开始，现实中为了与实际日历日期相符合通常采用第1天开始。下面就这两种方式举例说明。</p>

<p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-a90f0bb5ac7e37991945bbc47668cf1c_b.jpg&amp;valid=false" alt=""></p>

<p>第一种情况：活动从第0天开始，如图6-25</p>

<p>图6-25</p>

<p>计算公式如下：</p>

<p>对于当前活动：顺推时 <strong>EF = ES + DU</strong>； 逆推时 <strong>LS= LF – DU</strong></p>

<p>对于紧后活动：顺推时<strong>ESi= EFi-1,</strong> ；顺推时<strong>LFi-1 = LS i</strong> （例如逆推时活动C相当于活动D的紧后活动）</p>

<p>其中自左向右，“i”代表当前活动，则“i-1”代表“i”的紧前活动。</p>

<p>例如，</p>

<p>对于活动A、B的最早时间， EFA = ESA+DU = 0+5 = 5，ESB = EFA = 5；</p>

<p>对于活动D和C的最晚时间，LSD = LFD – DU = 30 -15 =15，LFC = LSD = 15；</p>

<p>第二种情况：活动从第1天开始，如图6-26</p>

<p>对于当前活动：顺推时 <strong>EF = （ES + DU）-1</strong>； 逆推时 <strong>LS =（LF – DU）+1</strong></p>

<p>对于紧后活动：顺推时<strong>ESi= EFi-1 +1</strong> ；逆推时<strong>LFi-1 = LS i -1</strong></p>

<p>其中自左向右，“i”代表当前活动，则“i-1”代表“i”的紧前活动。</p>

<p>例如，</p>

<p>对于活动A、B的最早时间， EFA = ESA+DU-1 = 1+5-1 = 5，ESB = EFA +1= 5+1 = 6；</p>

<p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic4.zhimg.com/v2-b8d00024d980b5ae1d4677bf084c86b7_b.jpg&amp;valid=false" alt=""></p>

<p>对于活动D和C的最晚时间，LSD = LFD – DU+1 = 30 -15 +1 =16，LFC = LSD -1 = 15；</p>

<p>图6-26</p>

<p>@提示</p>

<p>从上两种计算方法来看，活动从第0天开始显然对人工计算来说更加直观简便，这种方法的缺点是与日历日期的对应关系是不一致的。活动从第1天开始计算的结果与日历日期是一致的，但是计算过程是不直观的。好在考试中一般不会涉及具体的日历日期，所以推荐使用活动从第0天开始的计算方法。</p>

<p>**</p>

<p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-415e1c2817bef55e5ecb0752ac351368_b.jpg&amp;valid=false" alt=""></p>

<p>**</p>

<p><strong>顺推法与逆推法</strong></p>

<p>图6-27</p>

<p>自左向右计算最早时间称为顺推；自右向左计算最晚时间称为逆推。</p>

<p>在顺推时会出现如图6-27（左）的情况，即当前活动有两个和两个以上的紧前活动，那么当前活动的ES的取值应该遵循<strong>顺推取最大</strong>的原则，即ES0 = MAX（EF1，EF2，……）。</p>

<p>在逆推时也会出现如图6-27（右）的情况，即当前活动有两个和两个以上的紧后活动，那么当前活动的ES的取值应该遵循<strong>逆推取最小</strong>的原则，即ES0 = MIN（EF1，EF2，……）。</p>

<p>@提示</p>

<p>顺推法得到的最早工期代表项目期望的<strong>计划工期</strong>；逆推法时设定的最晚工期代表相关方的<strong>期望工期</strong>。</p>

<p><strong>总浮动时间TF</strong></p>

<ul>
  <li>定义：在任一网络路径上，进度活动可以从最早开始日期推迟或拖延的时间，而不至于<strong>延误项目完成日期或违反进度制约因素</strong>，就是总浮动时间或进度灵活性。</li>
  <li>取值：在进行紧前关系绘图法排序的过程中，取决于所用的制约因素，关键路径的总浮动时间可能是正值、零或负值。</li>
</ul>

<ol>
  <li>总浮动时间为<strong>正值</strong>，是由于逆推计算所使用的进度制约因素要晚于顺推计算所得出的最早完成日期，即给定的工期比计划的工期要长。</li>
  <li>总浮动时间为<strong>负值</strong>，是由于持续时间和逻辑关系违反了对最晚日期的制约因素，即给定的工期要比计划的工期要短。</li>
</ol>

<p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-62a51bcd5ceafeaa2bdac1b34d38faa8_b.jpg&amp;valid=false" alt=""></p>

<p>计算方法：TF = LS – ES = LF – EF，即按照图6-28箭头所示的方向求值。</p>

<p>图6-28</p>

<p><strong>负值浮动时间分析</strong></p>

<ul>
  <li>关键路径出现负的浮动时间意味着，如果不采取措施项目将延期。</li>
  <li>负值浮动时间分析是一种有助于找到推动延迟的进度回到正轨的方法的技术，从而找到保证工期的途径。</li>
  <li>为了使网络路径的总浮动时间为零或正值，可能需要调整活动持续时间（可增加资源或缩减范围时）、逻辑关系（针对选择性依赖关系时）、提前量和滞后量，或其他进度制约因素。</li>
</ul>

<p><strong>自由浮动时间FF</strong></p>

<ul>
  <li>自由浮动时间就是指在不延误任何紧后活动最早开始日期或不违反进度制约因素的前提下，某进度活动可以推迟的时间量。</li>
  <li>总浮动时间可能等于大于自由浮动时间，TF≥FF。</li>
</ul>

<p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-ce71edd5082994a7cec8192e7600bce8_b.jpg&amp;valid=false" alt=""></p>

<p>计算方法，如图6-29所示</p>

<p>图6-29</p>

<p>对于图6-29（左）的情况：活动0的FF0 = ES1 – EF0</p>

<p>对于图6-29（右）的情况：活动0的FF0 = MIN{ (ES1 – EF0), (ES2-EF0) ，……}</p>

<p>@提示</p>

<p>由于自由浮动时间的计算涉及前后活动之间的参数不容易记忆，只要记住图6-29所示的计算方式就不容易搞错了。</p>

<p><strong>项目浮动</strong></p>

<p>一个项目可以延误但不影响外界（如客户或发起人）限制的完工日期的时间。例如客户要求11.11号完工，项目团队的计划是在11.1完工，那么二者之间就有10天的浮动时间；如果按照客户要求日期完工，则项目浮动会反映在总浮动时间上。</p>

<p><strong>关键路径常见考点小结，请参考表6-7。</strong></p>

<p>表6-7</p>

<p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-ec483219c64cc3435c35247956b91008_b.jpg&amp;valid=false" alt=""></p>

<p><strong>关键路径法完整的计算示例</strong></p>

<p>请计算如表6-8所列活动的关键路径，并完成顺推计算最早时间和逆推计算最晚时间，计算所有活动的TF和活动C的自由浮动时间FF。</p>

<p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic3.zhimg.com/v2-a7809cbbe1f44e6306263ec2429b7436_b.jpg&amp;valid=false" alt=""></p>

<p>表6-8</p>

<p>第一步，画出网络图，如图6-30（1）</p>

<p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic4.zhimg.com/v2-718afcb3e1b4db5348425658ca885d13_b.jpg&amp;valid=false" alt=""></p>

<p>图6-30（1）</p>

<p>第二步：计算关键路径，列出所有可能的路径，比较其长度</p>

<ul>
  <li>路径A-B-F长度为2+2+2 = 6</li>
  <li>路径A-C-F长度为2+3+2 = 7</li>
  <li>路径A-D-E-F长度为2+4+2+2 = 10</li>
</ul>

<p>故关键路径为A-D-E-F，长度为10</p>

<p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic4.zhimg.com/v2-7a05e4bdba91e9290c3fd1e7a707f34b_b.jpg&amp;valid=false" alt=""></p>

<p>第三步：顺推计算最早时间，按照从第0天开始，如图6-30（2）</p>

<p>图6-30（2）</p>

<p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic3.zhimg.com/v2-205347a500ce3e2a13dbf746abf3079a_b.jpg&amp;valid=false" alt=""></p>

<p>第四步：逆推计算最晚时间，如图6-30（3）</p>

<p>图6-30（3）</p>

<p>第五步，计算所有活动的TF和活动C的FF，如图6-30（4）所示。</p>

<p>活动C的FF为：<strong>FFc = ESF-EFc = 8 – 5 = 3</strong></p>

<p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic2.zhimg.com/v2-1dba1bbbd1db7168887f172477616b0d_b.jpg&amp;valid=false" alt=""></p>

<p>6-30（4）</p>

<p>原创：陈利海</p>

<p>原载：易解项目管理（EasyPMP）</p>

<p><a href="https://cubox.pro/my/card?id=7098256758606399498" target="_blank">跳转到 Cubox 查看</a></p>
</body></html>
    </content>

    <side style="font-size: 0.9em">
      <h3 style="margin-bottom: 1em">反向链接：</h3>
      

      <div style="font-size: 0.9em">
        <p>
          There are no notes linking to this note.
        </p>
      </div>
      
    </side>
  </div>
</article>

<!-- <hr> -->

<!-- 图谱的性能太差，先屏蔽了 --></main>
      <footer><!-- <script src="https://giscus.app/client.js"
        data-repo="oldwinter/knowledge-garden"
        data-repo-id="R_kgDOHT-NGQ"
        data-category="备发布站的评论系统"
        data-category-id="DIC_kwDOHT-NGc4CQ3PF"
        data-mapping="og:title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script> -->
</footer>
    </div>
    <!-- That file is not particularly elegant. This will need a refactor at some point. -->
<style>
  content a.internal-link {
    border-color: #8b88e6;
    background-color: #efefff;
  }

  #tooltip-wrapper {
    background: white;
    padding: 1em;
    border: 1px solid #ddd;
    border-radius: 4px;
    overflow: hidden;
    position: absolute;
    width: 400px;
    height: 400px; /* 悬浮卡片改高一点 */
    font-size: 0.8em;
    box-shadow: 0 5px 10px rgba(0,0,0,0.1);
    opacity: 0;
    transition: opacity 100ms;
  }

  /* #tooltip-wrapper:after {
		content: "";
		position: absolute;
		z-index: 1;
		bottom: 0;
		left: 0;
		pointer-events: none;
		background-image: linear-gradient(to bottom, rgba(255,255,255, 0), rgba(255,255,255, 1) 90%);
		width: 100%;
		height: 75px;
  } */
</style>
<!-- 给悬浮预览卡片加滚动条。 -->
<div style="opacity: 0; display: none; overflow-y: scroll;" id='tooltip-wrapper'>
  <div id='tooltip-content'>
  </div>
</div>

<iframe style="display: none; height: 0; width: 0;" id='link-preview-iframe' src="">
</iframe>

<script>
  var opacityTimeout;
  var contentTimeout;
  var transitionDurationMs = 100;

  var iframe = document.getElementById('link-preview-iframe')
  var tooltipWrapper = document.getElementById('tooltip-wrapper')
  var tooltipContent = document.getElementById('tooltip-content')

  function hideTooltip() {
    opacityTimeout = setTimeout(function() {
      tooltipWrapper.style.opacity = 0;
      contentTimeout = setTimeout(function() {
        tooltipContent.innerHTML = '';
        tooltipWrapper.style.display = 'none';
      }, transitionDurationMs + 1);
    }, transitionDurationMs)
  }

  function showTooltip(event) {
    var elem = event.target;
    var elem_props = elem.getClientRects()[elem.getClientRects().length - 1];
    var top = window.pageYOffset || document.documentElement.scrollTop

    if (event.target.host === window.location.host) {
      iframe.src = event.target.href
      iframe.onload = function() {
        tooltipContentHtml = ''
        tooltipContentHtml += '<div style="font-weight: bold;">' + iframe.contentWindow.document.querySelector('h1').innerHTML + '</div>'
        tooltipContentHtml += iframe.contentWindow.document.querySelector('content').innerHTML

        tooltipContent.innerHTML = tooltipContentHtml

        tooltipWrapper.style.display = 'block';
        setTimeout(function() {
          tooltipWrapper.style.opacity = 1;
        }, 1)
      }

      tooltipWrapper.style.left = elem_props.left - (tooltipWrapper.offsetWidth / 2) + (elem_props.width / 2) + "px";
      if ((window.innerHeight - elem_props.top) < (tooltipWrapper.offsetHeight)) {
          tooltipWrapper.style.top = elem_props.top + top - tooltipWrapper.offsetHeight - 10 + "px";
      } else if ((window.innerHeight - elem_props.top) > (tooltipWrapper.offsetHeight)) {
          tooltipWrapper.style.top = elem_props.top + top + 35 + "px";
      }

      if ((elem_props.left + (elem_props.width / 2)) < (tooltipWrapper.offsetWidth / 2)) {
          tooltipWrapper.style.left = "10px";
      } else if ((document.body.clientWidth - elem_props.left - (elem_props.width / 2)) < (tooltipWrapper.offsetWidth / 2)) {
          tooltipWrapper.style.left = document.body.clientWidth - tooltipWrapper.offsetWidth - 20 + "px";
      }
    }
  }

  function setupListeners(linkElement) {
    linkElement.addEventListener('mouseleave', function(_event) {
      hideTooltip();
    });

    tooltipWrapper.addEventListener('mouseleave', function(_event) {
      hideTooltip();
    });

    linkElement.addEventListener('touchend', function(_event) {
      hideTooltip();
    });

    tooltipWrapper.addEventListener('touchend', function(_event) {
      hideTooltip();
    });

    linkElement.addEventListener('mouseenter', function(event) {
      clearTimeout(opacityTimeout);
      clearTimeout(contentTimeout);
      showTooltip(event);
    });

    tooltipWrapper.addEventListener('mouseenter', function(event) {
      clearTimeout(opacityTimeout);
      clearTimeout(contentTimeout);
    });
  }

  document.querySelectorAll('content a').forEach(setupListeners);
</script>

  </body>
</html>
